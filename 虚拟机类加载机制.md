# **虚拟机类加载机制**

# 概述
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机加载机制。

在Java语言里，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。
# 类加载的时机

类从被加载到虚拟机内存开始，到卸载出内存位置，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（UNloading）7个阶段。其中验证、准备和解析3个部分被称为连接（Linking）。

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后在开始，这是为了支持Java语言的运行时绑定（动态绑定或者晚期绑定）。这些阶段只是按部就班的开始，却通常是相互交叉地混合进行，通常会在一个阶段执行的过程中调用、激活另外一个阶段。
对于初始化阶段，虚拟机规范则严格规定了**有且只有5种**情况必须立即对类进行初始化

- 遇到new、getstatic、putstatic或invokestatic这4个字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。使用场景：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰的除外）的时候以及调用一个类的静态方法的时候。
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
- 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化
- 当虚拟机启动的时候，用户需要指定一个要执行的主类（包含main()函数的类），虚拟化主机会先初始化这个主类
- 当室友JDK1.7的动态语言支持的时候，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic和REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类还没有进行初始化，则先触发其初始化

**注意：** 通过数组定义来引用类，则不会触发此类的初始化。常量（或者final修饰的变量）在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义的常量的类，因此不会触发定义常量的类的初始化。
# 类加载过程
## 加载
加载过程完成3件事：
	- 通过一个类的全限定包名来获取定义此类的二进制字节流
	- 将这个字节流所代表的的静态存储	