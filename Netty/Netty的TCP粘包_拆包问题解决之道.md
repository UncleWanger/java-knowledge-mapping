# Netty的TCP粘包/拆包问题解决之道
# 1. TCP拆包/粘包的概念
TCP是“流”协议，流是没有界限的一串数据。TCP底层不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为一个完整的包可能会被TCP拆分成多个包进行发送，也可能会把多个小包封装成一个大包进行发送。这就是所谓的“TCP拆包/粘包”。
# 2.TCP拆包/粘包发生的原因
1) 应用程序write写入的字节大小大于套接字发送缓冲区大小
2) 进行MSS大小的TCP分段
3) 以太网帧的payload大于MTU进行IP分片
# 3.粘包问题的解决策略
1) 消息定长，例如每个报文的大小固定为200字节，如果不够，用空格补位。（资源浪费）
2) 在包尾增加回车换行符进行分割，例如FTP协议
3) 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常涉及思路为消息头的第一个字段使用int32来表示消息的总长度
4) 使用更复杂的应用层协议
# 3 Netty的TCP粘包问题解决
## 3.1 利用LineBasedFrameDecoder和StringDecoder解决TCP粘包问题
LineBasedFrameDecoder的工作原理是它依次遍历ByteBuf中的可读字节，判断看是否有"\n"或者"\r\n",如果有，就以此位置为结束位置，从可读索引到结束位置区间的字节就组成了一行。**它是以换行符为结束标志的解码器**，支持携带结束符或者不携带结束符两种方式，同时支持配置单行的最大长度。如果连续读取到最大长度后仍没有发现换行符，就会抛出异常。

StringDecoder的功能非常简单，就是将接收到的对象换成字符串，然后继续调用后面的Handler。

## 3.2 利用DelimiterBaseFrameDecoder和FixedLengthFrameDecoder解码
DelimiterBaseFrameDecoder是指定分隔符的解码器，
FixedLengthFrameDecoder是固定长度解码器，它能够按照指定长度对消息进行自动解码。

## 3.3 利用MessagePack编解码器对TCP拆包/半包问题支持
