# Java多线程学习
## 进程和线程
+ 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。
+ 线程与进程类似，但线程是一个比进程更小的执行单位，同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程或者在各个线程之间切换工作时，负担比进程小很多。

## 何为多线程
多线程就是多个线程同时运行或者交替运行。单核CPU的话是顺序执行，也就是交替执行。多核CPU的话，因为每个CPU有自己的运算器，所以在多个CPU中可以同时运行。

## 多线程的几个概念
+ 同步和异步
	*	同步和异步通常用来形容一次方法调用。
	*	同步方法一旦开始调用，调用者必须等到方法调用返回后，才能继续后续的操作。
	*	异步方法调用更像一个消息传递，一旦开始，方法调用立即返回，调用者可以继续后续的操作
+ 并发（Concurrency）和并行（Parallelism）
	*	并发偏重多个任务交替执行，而多个任务之间有可能是串行的。
	*	并行是真正意义上的“同时执行”
	*	多线程在单核CPU中式交替执行。在多核CPU中可以同时执行
+ 高并发
	* 高并发是互联网分布式系统架构设计中必须考虑的因素之一。通常指通过设计保证系统能够同时并行处理很多请求。
	* 高并发常用的一些指标有**响应时间，吞吐量，每秒查询率QPS，并发用户**等
+ 临界区
临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用。但每一次，只能有一个线程使用它，一单临界区资源被占用，其他线程想要使用这个资源，就必须等待。
+ 阻塞和非阻塞
	- 非阻塞指在不能立即得到结果前，该函数不会阻塞当前线程，而是会立即返回，
	- 阻塞与非阻塞刚好相反

## 使用多线程的三种方式
1. 继承Thread
2. 实现Runnable。推荐实现Runnable接口开发多线程，因为Java单继承但是可以多实现
3.使用线程池

## 常用方法说明
+ currentThread():返回当前正在执行的线程对象的引用
+ getId():返回此线程的标识符
+ getName():返回此线程名称
+ getPriority():返回此线程的优先级
+ isAlive():检测这个线程是否处于活动状态
+ sleep(long millis):使当前正在执行的线程以指定好描述休眠
+ interrupt():中断线程
+ join():等待该线程终止
+ yield():放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。放弃时间不确定

## synchronized关键字
Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为“重量级锁”。但是，在JavaSE 1.6之后进行了主要包括**为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化**之后变得在某些情况下并不是那么重了。
### 变量安全性
如果两个线程同时操作对象中的实例变量，则会出现“非线程安全”，解决办法就是在方法前加上synchronized关键字即可。
### 多个对象多个锁
由于synchronized用的是存在对象头里的。而不是把一段代码或方法当做锁。所以在线程执行中，无论哪个线程先执行带synchronized修饰的方法，则哪个线程就持有该方法属于对象的锁，那么其他线程只能处于等待状态。
### 锁的升级与对比
在Java SE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6之后，锁一共有4中状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁随着竞争情况逐渐升级，**只能升级，不能降级**
+ 偏向锁
	* 当一个线程访问同步块并获取锁时，会在对象头和栈帧的锁记录里存储锁偏向的线程ID，以后该线程再进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单测试一下对象头的Mark Word里是否存储着偏向锁，成功则表示已获得了锁。
+ 轻量级锁
	* 线程再执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁。解锁是加锁的逆过程。如果解锁失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
## synchronized的应用
+ 对于普通同步方法，锁是当前实例的对象
+ 对于静态同步方法，锁时当前类的Class对象
+ 对于同步方法块，锁时synchronized括号里配置的对象

## volatile关键字
volatile定义：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。
### volatile是如何保证可见性的？
有volatile变量修饰符的共享变量进行写操作时会在汇编指令中多出Lock前缀指令。这个指令**将当前处理器缓存行的数据写会到系统内存，这个写会内存的操作会让其他CPU里缓存了该内存地址的数据无效**。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条LOCK前缀的指令，将这个变量所在缓存的数据写会到系统内存。每个处理器通过嗅探在总线传播的数据来检查自己缓存的值是否是过期了，如果过期了，就会将当前处理器的缓存行设置为无效状态
### volatile不能替代synchronized
volatile不能保证对变量的原子性。它仅仅保证了共享变量对各个线程可见性。而不能解决多个线程之间访问的同步性
※ 锁的happens-before规则保证释放锁和获得锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到对这个volatile变量最后的写入
※ * volatile写的内存语义
	```
	当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存
	```
※ * volatile读的内存语义
	```
	当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来直接从主内存中读取共享变量
	```

## 等待/通知机制
等待/通知机制，是指一个线程A调用了对象Object的wait()方法进入等待状态，而另一个线程B调用了对象Object的notify()或者notifyAll()方法，线程A收到通知后从对象Object的wait()方法返回，进而执行后续操作。上述两个线程通过对象Object来完成交互，而对象Object的wait()和notify()/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方的交互工作。

### 等待/通知机制的相关方法

|方法名称|	描述|

|notify()	|随机唤醒等待队列中等待同一共享资源的 |“一个线程”，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知“一个线程”|
|notifyAll()	|使所有正在等待队列中等待同一共享资源的 “全部线程” 退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现|
|wait()	|使调用该方法的线程释放共享资源锁，然后从运行状态退出，进入等待队列，直到被再次唤醒|
|wait(long)	|超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回|
|wait(long，int)	|对于超时时间更细力度的控制，可以达到纳秒|

### 线程的基本状态
![线程基本状态](https://user-gold-cdn.xitu.io/2018/3/25/1625c6841963873b?w=876&h=492&f=png&s=-1)
