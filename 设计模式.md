# **设计模式**
设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
# 设计模式的分类
总体来说设计模式分为三大类：
* 创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模式中对象的创建和使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的细节，使整个系统的设计更加符合单一职责原则。

包含的模式共有5个：**工厂方法模式、抽象工厂模式、单例模式、建造者模式和原型模式**
* 结构型模式：**适配器模式、装饰器模式、代理模式、桥接模式、组合模式和享元模式**
* 行为型模式：**策略模式、模版方法模式、观察者模式、迭代模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、仲裁模式、解释器模式**

## 单例模式（Singleton）
全局生成唯一实例

[图解设计模式-单例模式](设计模式/图解设计模式-单例模式.md)
### 工厂模式（Factory）
将实例的生成交给子类

[图解设计模式-工厂模式](设计模式/图解设计模式-工厂模式.md)
### 建造者模式（Builder）
一步一步构建实例

[图解设计模式-建造者模式](设计模式/图解设计模式-建造者模式.md)
### 原型模式（prototype）
通过复制生成实例。
特点：要实现Cloneable接口。区分《[深克隆和浅克隆](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484076&idx=1&sn=0a7aeaeb283c5b2ca77dc4751995288c&chksm=fd9854cdcaefdddb1b6b9c637a14006ac3b54d325dd48ddcfc8a6b4ef74bd6e69a7e5e74eec8#rd)》。
### 适配器模式（Adapter）
使用一个已存在的、但又不符合需求的类，或者要创建一个可重用的类，这是可以考虑使用适配器模式。

适配器分为：类适配器和对象适配器。

类适配器：对象集成的方式，静态的定义

对象适配器：依赖于对象的组合

都是采用对象组合的方式，也就是对象适配器实现

[一起学设计模式](https://segmentfault.com/a/1190000011856448)
### 桥接模式（Bridge）
桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。桥接模式将继承关系转化为关联关系，从而降低类与类之间的耦合，减少了代码编写量。但是由于聚合关系建立在抽象层，所以系统的开发难度比较大

[桥接模式](https://blog.csdn.net/yangzl2008/article/details/7670996)

#### 组合模式（Composite）
组合模式能够使容器和内容具有一致性。创造出递归结构的模式就是组合模式。

组合模式又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。

[组合模式](https://blog.csdn.net/lmb55/article/details/51039781)
#### 装饰器模式（Decorator）
动态地给一个对象添加一些额外的职责。当不能采用生成子类的方法进行扩充时，可以采用此模式进行独立的扩展。

[装饰器模式](https://www.cnblogs.com/chenxing818/p/4705919.html)

#### 外观模式（Facade）
使用Facade模式可以为互相关联在一起的错综复杂的类整理出高层接口。其中的Facade角色可以让系统对外只有一个简单的接口。这使得子系统更容易被访问或者使用。

![外观模式](https://images2015.cnblogs.com/blog/1016421/201609/1016421-20160910215031051-160598096.png)

#### 享元模式（Flyweight Pattern）
享元模式（Flyweight Pattern），又称轻量级模式（这也是其英文名为FlyWeight的原因），通过共享技术有效地实现了大量细粒度对象的复用。也即**通过尽量共享来避免new出实例**

#### 代理模式（Proxy）
**只在必要时，生成实例**。

代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 RMI)，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。

[代理模式](https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/index.html)

#### 职责链模式（Chain of Responsibility）
将多个对象组成一条职责链，然后按照它们在职责上的顺序一个一个地找出到底应该谁来负责处理。
#### 迭代器模式（Iterator）
一个一个遍历。

**为什么要使用迭代器模式？**

一个重要理由，引入Iterator后可以将遍历与实现分离开。
```
这里的while循环并不依赖于具体对象。
Iterator it = bookshelf.Iterator();
while(it.hasNext()) {
    Book book = (Book)it.next();
    System.out.println(book.getName());
}
```

#### 模板方法模式（Template  Method）
**在父类中定义处理流程的框架，在子类中实现具体处理**
#### 策略模式（Strategy）
整体地替换算法。策略模式将算法与其他部分分离开，只是定义了与算法相关的接口，然后再程序中以委托的方式来使用算法。
#### 访问者模式（Visitor）
访问数据结构并处理数据。数据结构与处理被分离开来。我们编写一个“访问者”的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，我们只需要编写新的访问者，然后让数据结构可以接受访问者的访问即可。









