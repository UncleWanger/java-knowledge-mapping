# Java虚拟机实战
+ [概述](#概述)
+ [运行时数据区域](#运行时数据区域)
	- [Java虚拟机的内存结构](#Java虚拟机的内存结构)
	- [直接内存](#直接内存)
+ [对象分配的方式](#对象分配的方式)
+ [对象的访问](#对象的访问)
## 概述
对于Java程序员来说，在虚拟机自动内存管理机制下，不再需要像C/C++程序开发程序员这样为内一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。
## 运行时数据区域
Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干区域，这些区域有各自的用途，以及创建和销毁时间。
### Java虚拟机的内存结构

![Java虚拟机内存结构](https://oscimg.oschina.net/oscnet/22ed19bd1d5b59492f2e5c74202701668f5.jpg)
	* **1.堆（Heap）**是Java虚拟机所管理的内存中最大的一块。

	*	Java堆是被所有线程共享的一块内存区域。几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域。
	*	Java堆还被细分为：新生代和老年代；再细一点还将新生代分为Eden空间、from survivor和To survivor。通常配置**Eden:S0:S1区域的内存比例是8:1:1**，新生代和老年代比例是**1:3**。
	![堆内存](imgs/JVM_Heap.jpg)
	*	从内存分配角度来看，线程共享的Java堆可能分出多个线程私有的分配缓存区（Thread Local Allocation Buffer，TLAB）。
	* **2.方法区**也是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
	*	方法区也叫“永久区”，方法区在物理上也是不需要连续的，可以选择固定大小或者扩展的大小，还可以选择不实现垃圾收集，方法区的垃圾回收是比较少的，这就是方法区为什么被称为永久区的原因
	*	方法区也是可以执行回收的，该区域主要是针对常量池和类型的卸载
	*	方法区也规定当方法区无法满足内存分布的时候，将会抛出OutOfMemoryError异常
	*	运行时常量池（Runtime Constant Pool）是方法区的一部分，常量池存放编译器生成的各种字面量和符号引用。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
	* **3.虚拟机栈是线程私有的**。
	*	它的生命周期和线程相同。虚拟机栈描述的是**Java方法**执行的内存模型
	*	在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度（-Xss可调整栈大小）大于虚拟机所允许的深度，这个时候将会抛出StackOverFlowError异常，如果当Java虚拟机允许动态扩展虚拟机栈的时候，当扩展的时候没办法分配到内存的时候就会报OutOfMemoryError异常。
	* **4.本地方法栈**，与虚拟机栈基本相同，唯一的区别是虚拟机栈是执行Java方法的，本地方法栈则为虚拟机使用到的Native方法服务。与虚拟机一样会抛出Stack OverflowError和OutOfMemoryError异常。
	* **5.程序计数器**，是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器
	*	此内存区域是Java虚拟机唯一没有规定任何OutOfMemoryError的区域。
#### 直接内存
直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。

JDK1.4中新加入的*NIO(New Input/Output)*类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接*使用Native函数库*直接分配堆外内存，然后通过一个存储在*Java堆中的DirectByteBuffer*对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。

直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

### 对象分配的方式
	*	**new**一个对象，如果该对象很大（大数组对象），就直接分配到老年区，如果不是很大就分配带新生代的Eden区域。
	*	第一次GC的时候，会把Eden区域没有被回收的对象拷贝到**S0区域**
	*	第二次内存回收的时候会把Eden区域没有被回收的对象和S0区域的对象拷贝到S1区域，并且清空S0区域。
	*	再次内存回收的时候，会把Eden区域没有被回收的对象和S1区域的对象拷贝到S0区域，并且清空S1区域。
	*	如果经过多次GC（默认15次），仍没有被回收的对象，将被移动到**老年代**
	*	![对象创建](https://oscimg.oschina.net/oscnet/60e02d763275ab5aac0cafb52fdad4e8930.jpg)
### 对象的访问
我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有①使用句柄和②直接指针两种：
+ 句柄
	* 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
	* **好处**：reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普通的行为）时只会改变句柄中的实例数据指针而reference本身不需要修改。
	* ![句柄访问对象的方式](imgs/reference.jpg)
+ 直接指针
	* 如果使用直接指针访问，那么Java堆对象的布局中必须考虑如何放置类型数据的相关信息，而reference中存储的直接地址就是对象地址。
	* **好处**：速度更快，节省了一次指针定位的时间开销。**sun hotspot**虚拟机就是通过这种方式进行对象访问的。
	* ![直接指针方式访问对象](imgs/point.jpg)
